#!/usr/bin/env python3
from ev3dev2.motor import OUTPUT_B, OUTPUT_C, MoveTank, MoveSteering, LargeMotor, SpeedPercent
from ev3dev2.sensor.lego import ColorSensor
from ev3dev2.sensor import INPUT_2, INPUT_3
import time
import threading

class Navigate:
    
    def __init__(self, m_lock, minRef, maxRef, in_between_line):
        
        # Motors
        self.lm = LargeMotor(OUTPUT_B)
        self.rm = LargeMotor(OUTPUT_C)

        self.steering = MoveSteering(OUTPUT_B, OUTPUT_C)
        self.movetank = MoveTank(OUTPUT_B, OUTPUT_C)

        # Sensors
        self.lls = ColorSensor(INPUT_2)
        self.rls = ColorSensor(INPUT_3)

        # Constants
        self.minRef = minRef
        self.maxRef = maxRef

        self.in_between_line = None 
        
        # Threading
        self.pid = threading.Event()
        self.mlock = m_lock

    def reset_motor(self, right_motor = True, left_motor = True):
        if right_motor:
            self.rm.position = 0
        if left_motor:
            self.lm.position = 0
        

    def pid_follow(self,
                    kp,
                    ki,
                    kd,
                    speed,
                    pid_run = True,
                    target_light_intensity = None,
                    follow_right_edge = True,
                    right_light_sensor = True):
        
        if target_light_intensity is None:
            if self.in_between_line is None:
                raise ValueError('Missing Light Value')
            else:
                target_light_intensity = (100 * (self.in_between_line - self.minRef ) / ( self.maxRef - self.minRef)) 
        
        if right_light_sensor: ls = self.rls
        else: ls = self.lls
        
        ls.mode = 'COL-REFLECT'

        if follow_right_edge: polarity = 1
        else: polarity = -1 
        
        last_error = error = integral = 0.0
        derivative = 0.0
        cycle = 0

        while pid_run.is_set():
            
            reflected_light_intensity = (100 * ( ls.reflected_light_intensity - self.minRef ) / ( self.maxRef - self.minRef))
            error = target_light_intensity - reflected_light_intensity

            if error == 0:
                integral = 0
            else:
                integral = integral + error
            
            if not cycle == 0:
                derivative = error - last_error
            last_error = error

            steering = (kp * error) + (ki * integral) + (kd * derivative)
            steering *= polarity
            
            
            self.steering.on(steering, SpeedPercent(speed))
            cycle += 1

            # print('cycle:{c}, ref:{ref}, error:{err}, steering:{steer} '.format(c = cycle, ref = reflected_light_intensity, steer = steering, err = error))
        
        self.movetank.off()

    def align(self,
            start_spd,
            maxduration,
            marginoferror,
            target_light_intensity = None,
            black_white = True,
            correction_spd = None):

        if target_light_intensity is None:
            if self.in_between_line is None:
                raise ValueError('Missing Light value')
            else:
                target_light_intensity = self.in_between_line

        target_black = target_light_intensity - marginoferror
        target_white = target_light_intensity + marginoferror

        if correction_spd is None:
            correction_spd = start_spd
        
        forward_spd = -correction_spd
        backward_spd = correction_spd

        # Coarse Adjustment

        while True:
            self.movetank(start_spd)

            if black_white:

                # Aligning towards black Line 

                if self.lls.reflected_light_intensity <= target_light_intensity:
                    self.lm.off()
                    while not self.rls.reflected_light_intensity <= target_light_intensity:
                        self.rm.on(start_spd)
                    break
            
                else:
                    if self.rls.reflected_light_intensity <= target_light_intensity:
                        self.rm.off()
                        while not self.lls.reflected_light_intensity <= target_light_intensity:
                            self.lm.on(start_spd)
                        break
                    else:
                        pass
            
            else:

                # Aligning towards White Line

                if self.lls.reflected_light_intensity >= target_light_intensity:
                    self.lm.off()
                    while not self.rls.reflected_light_intensity >= target_light_intensity:
                        self.rm.on(start_spd)
                    break
            
                else:
                    if self.rls.reflected_light_intensity >= target_light_intensity:
                        self.rm.off()
                        while not self.lls.reflected_light_intensity >= target_light_intensity:
                            self.lm.on(start_spd)
                        break
                    else:
                        pass

        # Fine Adjustment
        start = time.perf_counter()
        end = 0 

        while not (end - start) > maxduration:
            if self.lls.reflected_light_intensity < target_black:
                self.lm.on(forward_spd)
            else:
                if self.lls.reflected_light_intensity > target_white:
                    self.lm.on(backward_spd)
                
                else:
                    self.lm.motor.off()
            
            if self.rls.reflected_light_intensity < target_black:
                self.rm.on(forward_spd)
            else:
                if self.rls.reflected_light_intensity > target_white:
                    self.rm.on(backward_spd)
                
                else:
                    self.rm.motor.off()
            
            if target_black < self.lls.reflected_light_intensity < target_white and target_black < self.rls.reflected_light_intensity < target_white:
                break
            
            end = time.perf_counter()

    def runpid(self,
                kp, 
                ki,
                kd,
                speed, 
                Daemon = None,
                target_light_intensity = None, 
                follow_right_edge = True, 
                right_light_sensor = True,
                poll_intersection = True):

        self.intersection = False
        self.pid.set()
        self._pid = threading.Thread(target = self.pid_follow, args = (kp,ki,kd,speed), kwargs = {'target_light_intensity' : target_light_intensity, 'follow_right_edge' : follow_right_edge, 'right_light_sensor' : right_light_sensor, 'pid_run' : self.pid}, daemon = Daemon)
        self._pid.start()
    
    def stop_pid(self):
        self.pid.clear()
        self._pid.join()
    
