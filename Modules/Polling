#!/usr/bin/env python3
import threading
from ev3dev2.sensor.lego import ColorSensor, UltrasonicSensor
from ev3dev2.motor import LargeMotor,OUTPUT_B, OUTPUT_C
from ev3dev2.sound import Sound

class Poll:
    def __init__(self,m_lock, *sensors):

        #Sensors 
        self.lls = list(filter(lambda x:isinstance(x,ColorSensor),sensors))[0]
        self.rls = list(filter(lambda x:isinstance(x,ColorSensor),sensors))[1]

        self.us = list(filter(lambda x:isinstance(x,UltrasonicSensor),sensors))[0]
        self.lm = LargeMotor(OUTPUT_B)
        self.rm = LargeMotor(OUTPUT_C)
        
        #Lock
        self.mlock = m_lock 
        
        #Threading - Event
        self.inters_evt = threading.Event()
        self.us_evt = threading.Event()

        # Threading - Thread
        self._us = threading.Thread()
        self._inters = threading.Thread()

        # Logging
        self.ls_log = []
        
        self.intersection_log = []
        self.intersection = 0

        self.us_log = []
    
    def inters_poll(self, right_light_sensor, poll_run = True):
        
        if right_light_sensor:
            ls = self.rls       
        else: 
            ls = self.lls
        
        ls.mode = 'COL-REFLECT'
        p_int = None
        cycle = 0
        self.ls_log = []
        ofvalue = []

        while poll_run.is_set():
            
            reflected_light_intensity = (100 * ( ls.reflected_light_intensity - 0 ) / ( 50 - 0))
            
            self.ls_log.append(reflected_light_intensity)

            if reflected_light_intensity >= 70: _int = 2
            elif reflected_light_intensity <= 30: _int = 1
            else: _int = 0

            if _int != p_int:
                if _int == 2:
                    ofvalue.append([_int, cycle])
                    try:
                        if ofvalue[-1][1] - ofvalue[-2][1] <= 20:
                            for x in self.ls_log[ofvalue[-2][1] + 1: ofvalue[-1][1]]:
                                if x == 1:
                                    self.intersection += 1
                                    with self.mlock:
                                        self.intersection_log.append([self.intersection,self.lm.position,self.rm.position])
                                    Sound().play_note('A4', 0.05)
                                    break          
                    except:
                        pass
                else:
                    if cycle != 0:
                        if self.ls_log[-1] == 2:
                            ofvalue.append([2, cycle - 1])
                p_int = _int
        
            self.ls_log.append(_int)
            cycle += 1
        print(ofvalue)      

    def us_poll(self, poll_run = True):
        while poll_run.is_set():
            self.us_log.append(self.us.distance_centimeters)
            #print(self.us.distance_centimeters)
    
    def start_us_poll(self):
        self.us_evt.set()
        self._us = threading.Thread(target = self.us_poll,kwargs = {'poll_run':self.us_evt}, daemon = None)
        self._us.start()

    def us_stop(self):
        self.us_evt.clear()
        self._us.join()

    def start_inters_poll(self, right_light_sensor = False):
        self.inters_evt.set()
        self._inters = threading.Thread(target = self.inters_poll, kwargs = {'right_light_sensor': right_light_sensor,'poll_run': self.inters_evt})
        self._inters.start()

    def inters_stop(self):
        self.inters_evt.clear()
        self._inters.join()
        
    def clear_log(self):
        self.ls_log = []
        self.intersection_log = [] 
        self.intersection = 0
    
        
    
        
