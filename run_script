#!/usr/bin/env python3
# pyright: reportMissingImports=false

from ev3dev2.motor import OUTPUT_A, OUTPUT_B,OUTPUT_C, OUTPUT_D, MoveTank, MoveSteering, LargeMotor, MediumMotor, SpeedPercent
from ev3dev2.led import Leds
from ev3dev2.button import Button
from ev3dev2.sensor.lego import ColorSensor, UltrasonicSensor
from ev3dev2.sensor import INPUT_1, INPUT_2, INPUT_3, INPUT_4
from ev3dev2.sound import Sound
import time
import threading
from importlib.machinery import SourceFileLoader

Navigation = SourceFileLoader('Navigation', '/home/robot/Nrc2021/Modules/Navigation').load_module()
Memory = SourceFileLoader('Memory', '/home/robot/Nrc2021/Modules/Memory').load_module()
Polling = SourceFileLoader('Polling', '/home/robot/Nrc2021/Modules/Polling').load_module()
Storage = SourceFileLoader('car_storage', '/home/robot/Nrc2021/Modules/car_storage').load_module()

# Instantiate Brick
leds = Leds()
btn = Button()
spk = Sound()

# Instantiate Sensors
left_ls = ColorSensor(INPUT_2)
right_ls = ColorSensor(INPUT_3)

# Instantiate Motors
lm = LargeMotor(OUTPUT_B)
rm = LargeMotor(OUTPUT_C)

steering = MoveSteering(OUTPUT_B, OUTPUT_C)
tank = MoveTank(OUTPUT_B, OUTPUT_C)

# Threading
m_lock = threading.Lock()

# Min/Max Reflective Value
minRef = 0
maxRef = 50
lls_Ref_black_white = 23
rls_Ref_black_white = 22

# Initialize instances

ctrl = Navigation.Navigate(m_lock, minRef, maxRef, lls_Ref_black_white, rls_Ref_black_white)
mem = Memory.Memory()
store = Storage.Storage(mem)
poll = Polling.Poll(m_lock, minRef, maxRef, ctrl.rm, ctrl.lm, mem, 40.0, 25.0, 18.0, 5.0, False, False, 70, ctrl)

left_ls.mode = 'COL-REFLECT'
right_ls.mode = 'COL-REFLECT'
# Start

leds.set_color('LEFT', 'RED')
leds.set_color('RIGHT', 'RED')
print('Ready')

# while not btn.enter:
#     pass
# leds.all_off()

## Run starts

time_start = time.perf_counter()

# Escape base
tank.on_for_degrees(35, 35, 200)
steering.on_for_seconds(100, 50, 0.25)


lm.on(15)
rm.on(15)
time.sleep(1)

while True:
    x = left_ls.reflected_light_intensity
    y = right_ls.reflected_light_intensity

    if x > 40 : lm.off()
    if y > 40 : rm.off()
    if not lm.is_running and not rm.is_running: break

steering.on(50, 15)
while not left_ls.reflected_light_intensity < 10:
    pass
while not left_ls.reflected_light_intensity > 40:
    pass
while not left_ls.reflected_light_intensity < 40:
    pass 
steering.off()

# Align to collect first 2 batteries
ctrl.runpid(0.15, 0, 1 ,20, right_light_sensor = False, follow_right_edge = False)

poll.start_inters_poll(right_light_sensor = True, object_detection = False)

while True:
    if poll.intersection == 1: 
        break 

poll.inters_stop()
time.sleep(0.05)
ctrl.stop_pid()
poll.intersection = 0

ctrl.runpid(0.17, 0, 1 ,15, right_light_sensor = False, follow_right_edge = False, forward = False)

while not right_ls.reflected_light_intensity < 10:
        pass
while not right_ls.reflected_light_intensity > 40:
    pass
ctrl.stop_pid()
tank.on_for_degrees(-20, -20, 75) 

# Collect first 2 batteries
ctrl.turn(turn_right = True)

tank.on(-20, -20)
while True:
    if right_ls.reflected_light_intensity > 35 and left_ls.reflected_light_intensity > 35:
        break # To avoid the grey zone

ctrl.align(20,2,3, black_white = True, correction_spd = 10, pos_beforeline = False, target_light_intensity = 20)

tank.on_for_degrees(20,20, 230) 
tank.off()

time.sleep(2)

tank.on_for_degrees(-20,-20, 150)

ctrl.turn(turn_right = False)

# Align to collect next 2 batteries
ctrl.runpid(0.12, 0, 1 ,30, right_light_sensor = False, follow_right_edge = False)

poll.start_inters_poll(right_light_sensor = True, object_detection = False)

while True:
    if poll.intersection == 1: 
        break 
poll.inters_stop()
time.sleep(0.15)
ctrl.stop_pid()
poll.intersection = 0

ctrl.runpid(0.18, 0, 1 ,15, right_light_sensor = False, follow_right_edge = False, forward = False)

while not right_ls.reflected_light_intensity < 10:
        pass
ctrl.stop_pid()
tank.on_for_degrees(20, 20, 105)

# Collect next 2 batteries
ctrl.turn(turn_right = True)
tank.on(-15, -15)
time.sleep(0.2)

while not right_ls.reflected_light_intensity < 10:
    pass 
while not right_ls.reflected_light_intensity > 40:
    pass
tank.off()

ctrl.align(15,2,3, black_white = True, correction_spd = 10, pos_beforeline = True)

tank.on_for_degrees(20,20, 250)

time.sleep(2)

tank.on_for_degrees(-20,-20, 80)
tank.off()

# Align to collect row of cars

ctrl.turn(turn_right = False)
tank.on(-20,-20)

time.sleep(0.5)
while not left_ls.reflected_light_intensity < 10 :
    pass
tank.off()

tank.on(10,10)
while not left_ls.reflected_light_intensity > 40:
    pass
time.sleep(0.15)
tank.off()

ctrl.turn(turn_right = False)
tank.on(20,20)
while not right_ls.reflected_light_intensity < 10:
    pass
while not right_ls.reflected_light_intensity > 40:
    pass
tank.off()

ctrl.align(15,2,3, black_white = True, correction_spd = 10, pos_beforeline = False)

# Collect all the car
tank.on_for_degrees(20, 20, 1000)

# Caculate duration of run
time_end = time.perf_counter()
diff = round(time_end - time_start, 1)
print(diff)

