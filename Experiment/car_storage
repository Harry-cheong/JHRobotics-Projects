#!/usr/bin/env python3
# pyright: reportMissingImports=false

from ev3dev2.led import Leds
from ev3dev2.button import Button
from ev3dev2.sensor.lego import ColorSensor
from ev3dev2.sensor import INPUT_1, INPUT_2, INPUT_3
from ev3dev2.motor import MediumMotor ,OUTPUT_A, OUTPUT_D, SpeedPercent # A is storage moving, D is pusher
import time

btn = Button()
leds = Leds()

class Storage:
    def __init__(self):
        self.cars = {
                    'R' : 0, 
                    'B' : 0, 
                    'G' : 0,
                    }
        
        self.pos_cars = {
                        1 : [], 
                        2 : [], 
                        3 : [],
                        4 : [],
                        5 : [],
                        6 : [],
                        }
        self.pos_vacant = [1, 2, 3, 4, 5, 6]
        self.pos_poi = None
        self.pos_battery = [1,3,4,6]
        self.pos_alignedto = None

        # Motors
        self.storage_motor = MediumMotor(OUTPUT_A)
        self.pusher_motor = MediumMotor(OUTPUT_D)

        # Sensors
        self.ls = ColorSensor(INPUT_1)

    def find_car(self, colour, left_side = False, right_side = False, type_rechargeable = False):
        
        pos_to_check = []
        pos_poi = []

        if left_side:
            pos_to_check = [1, 2, 3]
        
        if right_side:
            pos_to_check = [4, 5, 6]

        if not left_side and not right_side:
            pos_to_check = [1, 2, 3, 4, 5, 6]


        if type_rechargeable and colour == 'G':
            for x in pos_to_check:
                if self.pos_cars[x] == ['G', 'R']:
                    pos_poi.append(x)
            
            if len(pos_poi) > 0:
                    self.pos_poi = pos_poi
                    return True
            else:
                return False

        elif type_rechargeable and colour == 'B':
            for x in pos_to_check:
                if self.pos_cars[x] == ['B', 'R']:
                    pos_poi.append(x)
            
            if len(pos_poi) > 0:
                    self.pos_poi = pos_poi
                    return True
            else:
                return False
        
        else:

            if colour == 'R':
                if self.cars['R'] != 0: 
                    for x in pos_to_check:
                        if self.pos_cars[x] == ['R']:
                            pos_poi.append(x)
                    
                    if len(pos_poi) > 0:
                        self.pos_poi = pos_poi
                        return True
                    else:
                        return False
                else:
                    return False

            elif colour == 'G':
                if self.cars['G'] != 0: 
                    for x in pos_to_check:
                        if self.pos_cars[x] == ['G']:
                            pos_poi.append(x)
                    
                    if len(pos_poi) > 0:
                        self.pos_poi = pos_poi
                        return True
                    else:
                        return False
                else:
                    return False


            elif colour == 'B':
                if self.cars['B'] != 0: 
                    for x in pos_to_check:
                        if self.pos_cars[x] == ['B']:
                            pos_poi.append(x)
                    
                    if len(pos_poi) > 0:
                        self.pos_poi = pos_poi
                        return True
                    else:
                        return False
                else:
                    return False
        
            else:
                raise ValueError('Invalid Car Colour')
    
    def align_storage(self, pos):
        # Motor coordination to align storage to the right position
        # Include pos 1, 2, 3, 4, 5, 6 
        self.pos_alignedto = pos
        
    def reset_storage(self, current_pos = None):
        if current_pos is None:
            current_pos = self.pos_alignedto
        
        # reset Medium motor to mid pos

    def eject_car(self, motor_spd):
        
        proximity = []

        if len(self.pos_poi) == 1:
            self.align_storage(self.pos_poi[0])

            self.pusher_motor.on(SpeedPercent(motor_spd))
            while not self.pusher_motor.is_stalled:
                pass
            self.pusher_motor.off()

            self.pusher_motor.on(SpeedPercent(-motor_spd))
            time.sleep(0.1)
            while not self.pusher_motor.is_stalled:
                pass
            self.pusher_motor.on()

            self.reset_storage()

        
        elif len(self.pos_poi) > 1:
            for x in self.pos_poi:
                if x > 3:
                    proximity.append(x - 4)
                else:
                    proximity.append(3 - x)
            self.align_storage(self.pos_poi[proximity.index(min(proximity))])
            # Warning if the proximity is the same, this will throw an error. However, the chances of that happening is very low. 
            
            self.pusher_motor.on(SpeedPercent(motor_spd))
            while not self.pusher_motor.is_stalled:
                pass
            self.pusher_motor.off()

            self.pusher_motor.on(SpeedPercent(-motor_spd))
            time.sleep(0.1)
            while not self.pusher_motor.is_stalled:
                pass
            self.pusher_motor.on()

            self.reset_storage()
                
        else:
            raise AttributeError('No valid pos')
        
        self.pos_poi = []
       
    def store_car(self,colour, type_rechargeable = False):
        pass
